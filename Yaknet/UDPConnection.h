/* (c) 2015 Michael R. Tirado -- GPLv3, GNU General Public License, version 3.
 * contact: mtirado418@gmail.com
 *
 */ 

#ifndef __UDPCONNECTION_H__
#define __UDPCONNECTION_H__

#include "Connection.h"
#include "Yaknet/DataStructures/map_keys.h"
#include "Yaknet/DataStructures/TList.h"

//really long distances may require more time?
//handshake timout
#define CONN_REQ_ATTEMPTS 12
#define CONN_REQ_TIMEOUT  1.5 * 1000

//TODO implement a connection pulse so server doesnt drop loiterous connections
#define CONN_TIMEOUT      100  * 1000 //drop after 100 seconds inactive

//connection related messages
#define UDP_CONN_REQUEST  65535
#define UDP_CONN_ACK      65534
#define UDP_CONN_VALIDATE 65533


///UDP connection with a some overhead in place to frame connectionless packets
///within this Connection interface, plus create and maintain loose connections
///the packet size should be kept under 576 bytes to avoid fragmentation.
///TODO add a way to ignore handshake for standard udp. TODO test handshake over INET
///all master UDP connection need to call Listen to create the shared socket for tx/rx

///datagram "connection" (unreliable packet delivery)
class UDPConnection : public Connection
{
protected:
    //pending connections, yeah a little bloated i guess. but its not too bad at least?
    TList<UDPConnection *>  outgoingConnections;
    std::map<sockaddr_key_t, UDPConnection *> incomingConnections;

    time_t lastActivity;        //last time a packet has been received from connection
    char    numConnAttempts; //how many times we have sent connection requests.
    char    handshakeStage;  //what stage of the handshake? TODO throw this in status bit field

    //session key is generated by a host to identify the connection on a higher level.
    //if you want to tie a UDP with an already established TCP connection, you can request the session key
    //from the host and send it with the connection request. the host will respond with a challenge
    //that must be solved before the connection will be trusted. not great security, but better than nothing.
    //TODO session keys, and actual authentication other than a dummy handshake.
    void SendConnectionRequest(unsigned int sessionKey = 0);
    void CheckHandshake(); //handles handshake logic, waits for server ack's and retransmits requests
    void SendChallengeResponse(); //send the solution for host challenge
    void HandleConnectionRequest(sockaddr_in sender, char *data, unsigned short size);
    void HandleValidationRequest(sockaddr_in sender, char *data, unsigned short size);
    void HandleConnectionAck(sockaddr_in sender, char *data, unsigned short size);     //gets called when connection is acknowledged
public:

    UDPConnection(NetEvents *netEvents);
    ~UDPConnection();
    
    ///executes connection drops, calls select and updates read set
    ///listening connections must call this every server tick
    virtual void BeginTick();
    virtual Connection *AcceptConnection();
    virtual void DropConnection(Connection *conn);
    ///will return the new connection, but it will not be validated untill the hand shake is completed.
    ///all master UDP connections must be listening, in order to receive connect handshake responses,
    ///and to transmit/receive for its entire connection list
    virtual Connection *Connect(const char *ipAddr, unsigned short port);
    virtual void Disconnect();
    //sends to only this connection
    virtual bool SendData(char *data, unsigned short eventId);
    //sends to all other connections in connection list
    virtual bool SendDataToAllConnections(char *data, unsigned short eventId);

    ///disabled, UDP receives all by default this could be implemented, but the overheard would be obnoxious
    virtual int  RecvData() {}
    
    //recv from all connections
    virtual int RecvFromAllConnections();
};

#endif
